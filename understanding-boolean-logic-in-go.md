#[理解 Go 中的布尔逻辑](https://www.digitalocean.com/community/tutorials/understanding-boolean-logic-in-go)

由 **Gopher Guides** 编写

> 布尔数据类型（`bool`）可以是 **true**  或者 **false** 中的一个，在程序中常被用来做比较和控制流程走向。

> 布尔值表示与数学逻辑分支相关联的真值，该真值勇于通知计算机科学中的算法。布尔（Boolean）一词以数学家 George Boole 的名字命名，总是以大写的 `B` 开头。

> Go 中布尔值的数据类型为 `bool`，均为小写。值 `true` 和 `false` 始终分别使用小写的 `t` 和 `f` ，因为它们在 Go 中是特殊值

> 本教程将介绍您需要了解的布尔数据类型如何工作的基础知识，包括布尔比较，逻辑运算符和真值表。

## 比较运算符

> 在编程中，比较运算符通常用于值的比较，并判定为布尔值的 *true* 或者 *false*。

> 下面的表格展示了布尔值的比较运算符：

| 操作符 |    表示    |
| :----: | :--------: |
|   ==   |    等于    |
|   !=   |   不等于   |
|   <    |    小于    |
|   >    |    大于    |
|   <=   | 小于或等于 |
|  \>=   | 大于或等于 |

> 为了理解这些运算符的工作原理，我们在 Go 程序中定义两个整型变量：

```go
x := 5 
y := 8
```

> 在这个例子中，`x` 的值为 `5` ，小于值为 `8` 的 `y`。

> 使用这两个变量及其关联的值，让我们便利上表中的运算符。在此程序中，将打印出每个比较运算符的结果为 **是（true）** 还是 **否（false）**。为了更好地理解输出结果，我们在前面加上其代表的比较内容：

```go
package main 

import "fmt"

func main() { 
  x := 5
  y := 8
  
  fmt.Println("x == y:", x == y) 
  fmt.Println("x != y:", x != y) 
  fmt.Println("x < y:", x < y) 
  fmt.Println("x > y:", x > y) 
  fmt.Println("x <= y:", x <= y) 
  fmt.Println("x >= y:", x >= y)
}
```

输出：

```go
x == y: false 
x != y: true 
x < y: true 
x > y: false 
x <= y: true 
x >= y: false
```

> 按照数学逻辑，Go 从表达式中求出了以下值：

- 5 （x）等于 8（y）？ **false**
- 5 （x）不等于 8（y）？ **true**
- 5 （x）小于 8（y）？ **true**
- 5 （x）大于 8（y）？ **false**
- 5 （x）小于等于 8（y）？ **true**
- 5 （x）大于等于 8（y）？ **false**

> 这里使用的是整型数，您也可以将它们替换为浮点型的数据。

> 字符串也可以与布尔运算符一起使用，默认是区分大小写的，除非用了其他的字符串方法。

> 您可以通过实例查看字符串是如何比较的：

```go
Sammy := "Sammy" 
sammy := "sammy"

fmt.Println("Sammy == sammy: ", Sammy == sammy) 
```

输出：

```go
Sammy == sammy: false
```

> 字符串 `Sammy` 与 `sammy` 是不等的，因为它们不是完全相同的；一个以大写的 `S` 开头，另一个以小写的 `s` 开头。但是如果我们新建一个新的变量，并且赋值为 `Sammy`，它们就会相等：

```go
Sammy := "Sammy" 
sammy := "sammy"
alsoSammy := "Sammy"

fmt.Println("Sammy == sammy: ", Sammy == sammy)
fmt.Println("Sammy == alsoSammy: ", Sammy == alsoSamm
```

输出：

```go
Sammy == sammy: false 
Sammy == alsoSammy: true
```

> 您可以使用包含  `>`  和 ` <` 的其他比较运算符比较两个字符串，Go将使用字符的 ASCII 值按字典顺序比较这些字符串。

> 您还可以通过比较运算符比较布尔类型的数据。

```go
t := true 
f := false

fmt.Println("t != f: ", t != f)
```

输出：

```go
t!=f: true
```

> 上面的结果表明 `true` 与 `false` 不相等。

> 要注意操作符 `=` 和 `==`  的区别

```go
x = y 	// 将 x 设为和 y 相等的值
x == y  // 判断 x 和 y 是否相等
```

> 第一个 `=` 是赋值操作符，可以将一个变量设为和右边相等。第二个 `==` 是比较运算符，用来比较两个值是否相等。

## 逻辑运算符

有三个用于比较值的逻辑运算符，他们将表达式计算为布尔值，返回 `true` 或 `false` 。这些运算符是 `&&`、 `||` 和 `!`，他们所代表的含义如以下列表所示：

|   运算符   | 使用方法 |              含义               |
| :--------: | :------: | :-----------------------------: |
|  &&（与）  |  x && y  |  两个都是 true 表达式才为 true  |
| \|\|（或） | x \|\| y | 其中一个为 true 则表达式为 true |
|  ！（非）  |    !x    |   x 为 false 时表达式为 true    |

> 逻辑运算符通常用来判断两个或多个表达式为真或假。例如，只有当某学生成绩合格并且选择了这门课程这两个条件都成立的时候，才可以在系统中为该学生评级。另一个例子是，根据用户是否拥有商店的消费卡或在过去 6 个月中购买过该店商品，确定用户是否是网店的有效活跃客户。

> 为了理解逻辑运算符的工作方式，我们来看下面的三个表达式：

```go
fmt.Println((9 > 7) && (2 < 4))   // 两个原始表达式都为 true
fmt.Println((8 == 8) || (6 != 6)) // 一个原始表达式为 true
fmt.Println(!(3 <= 1))            // 原始表达式为 false
```

输出：

```go
true
true
true
```

> 在第一种情况下，`fmt.println((9 > 7) && (2 < 4))` 中，由于使用了 `and` 运算符，`9 > 7` 和 `2 < 4` 都需要为 `true` 。

> 在第二种情况下，`fmt.Println((8 == 8) || (6 != 6))`，由于 `8 == 8` 计算为 `true`，`6 != 6` 计算为`false`，因为使用了`or`运算符所以对结果没有影响。如果您使用的是 `and` 运算符，则整个运算结果将为 `false`。

> 在第三种情况下，`fmt.Println(!(3 <= 1))`， `非` 运算符反转了 `3 <= 1` 返回的 `false` 值。

> 让我们用浮点数代替整数，然后使运算结果为 `false`：

```go
fmt.Println((-0.2 > 1.4) && (0.8 < 3.1))  // 其中一个原始表达式为 false
fmt.Println((7.5 == 8.9) || (9.2 != 9.2)) // 两个原始表达式都是 false
fmt.Println(!(-5.7 <= 0.3))               // 原始表达式为 true
```

> 在这个例子中：

- `与` 必须至少有一个错误的表达式结果为 `false`
- `或` 必须两个表达式的结果都为 `false`
- `非` 必须使内部的表达式为 `true`，新表达式的结果才能为 `false`

> 如果您对这些结果不清楚，可以通过一些 [真值表](https://www.digitalocean.com/community/tutorials/understanding-boolean-logic-in-go#truth-tables) 进一步查看。 

您也可以使用 `&&` ，`||` 和 `!`  写复合语句：

```go
!((-0.2 > 1.4) && ((0.8 < 3.1) || (0.1 == 0.1)))
```

> 首先看一下最里面的表达式： `(0.8 < 3.1) || (0.1 == 0.1)` ，因为两个数学表达式都为 `true` 所以运算结果为 `true` 。

> 接下来，Go 将返回值 `true` 与下一个内部表达式拼接在一起：`(-0.2 > 1.4) && (true)` 。此示例返回 `false`，因为数学表达式  `-0.2 > 1.4` 的结果为 `false`，(`false`) 与 (`true`) 返回 `false` 。 

> 最后，我们有一个外部表达式： `!(false)` ，其结果为 `true` ，因此我们打印出最终的返回值是：

```go
true
```

> 逻辑运算符 `&&` ，`||`  和  `!` 计算表达式并返回布尔类型的值。

## 真值表

> 关于数学的逻辑分支，有很多知识要学习，但是您可以有选择地学习其中的一部分来提高编程时的算法思维。

> 下面依次是比较运算符 `==`, 逻辑运算符 `&&` ，`||` 和 ` !`  对应的真值表。您可能会通过计算得出它们的结果，但是直接记住它们可以使您在编程时更快得做出决策。

### `==` (等于) 真值表

| x     | ==   | y     | 返回值 |
| ----- | ---- | ----- | ------ |
| true  | ==   | true  | true   |
| true  | ==   | false | false  |
| false | ==   | true  | false  |
| false | ==   | false | true   |

### `&&` (与) 真值表

| x     | and  | y     | Returns |
| ----- | ---- | ----- | ------- |
| true  | and  | true  | true    |
| true  | and  | false | false   |
| false | and  | true  | false   |
| false | and  | false | false   |

### `||` (或) 真值表

| x     | or   | y     | Returns |
| ----- | ---- | ----- | ------- |
| true  | or   | true  | true    |
| true  | or   | false | true    |
| false | or   | true  | true    |
| false | or   | false | false   |

### `!` (非) 真值表

| not  | x     | 返回值 |
| ---- | ----- | ------ |
| not  | true  | false  |
| not  | false | true   |

> 真值表是逻辑中常用的数学表，在构造计算机程序中的算法（指令）时要牢记这些信息。

## 用布尔运算符进行流程控制

> 要以流控制语句的形式控制程序的走向和结果，可以使用*条件判断*然后后面加一个*子句*。

> *条件判断* 的结果是布尔类型的 `true` 或者 `false` ，表明程序在这个地方做了判断。也就是说，条件会告诉您某个表达式的值为真还是假。

> *子句*  是符合 *条件判断* 并决定程序结果的代码块。也就是说，它是 “如果 `x` 是 `true`，则执行此操作” 中的 “执行此操作” 部分。

> 下面的代码是比较运算符与条件语句一起控制 Go 程序流程的示例：

```go
if grade >= 65 {                 // 判断条件
    fmt.Println("Passing grade") // 子句
} else {
    fmt.Println("Failing grade")
}
```

> 上面的代码用来判断学生的分数是否合格。如果某个学生的成绩是 `83` ，开始的判断条件结果就为 `true` ，结果打印出`Passing grade` 。对于成绩为 `59` 的学生 ，第一个语句的判定结果为 `false` ，所以程序将执行另外一个与 `else`  绑定的打印语句：`Failing grade` 。

> 可以通过使用包含布尔运算符的流程控制语句来决定程序运行的结果。

## 结论

> 这节教程介绍了布尔类型的比较运算符和逻辑运算符，以及真值表，并使用布尔值进行程序流控制。

